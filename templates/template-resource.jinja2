{% import 'macros.jinja2' as custom_mac -%}
# -*- coding: utf-8 -*-
"""
Profile: {{ profile.url }}
Release: {{ release_name }}
Version: {{ profile.fhir_version }}
{%- if info.build %}
Build ID: {{ info.build }}
{%- elif info.revision %}
Revision: {{ info.revision }}
{%- endif %}
Last updated: {{ profile.fhir_last_updated }}
"""
{%- if has_array_type %}
from typing import List as ListType
{% endif %}
from pydantic import Field
{%- if has_one_of_many %}
from pydantic import root_validator
from typing import Dict
from typing import Any
{% endif %}
{%- if need_fhirtypes %}
from . import fhirtypes
{% endif %}
{%- set imported = {} %}
{%- for klass in classes %}


{% if klass.superclass in imports and klass.superclass.module not in imported -%}
from . import {{ klass.superclass.module }}
{% set _ = imported.update({klass.superclass.module: True}) %}
{% endif -%}

class {{ klass.name }}({% if klass.superclass in imports %}{{ klass.superclass.module }}.{% endif -%}
    {{ klass.superclass.name|default('object')}}):
    """ {{ klass.short|wordwrap(width=75, wrapstring="\n    ") }}.
{%- if klass.formal %}
    {{ klass.formal|wordwrap(width=75, wrapstring="\n    ") }}
{%- endif %}
    """
{%- if klass.resource_type %}
    resource_type = Field("{{ klass.resource_type }}", const=True)
{%- endif %}
{%- for prop in klass.properties %}
	{% set type_klass_ %}
		{%- if prop.field_type_module %}{{ prop.field_type_module }}.{{ prop.field_type }}{% else %}{{ prop.field_type }}{% endif -%}
	{%endset -%}
	{%- set type_klass %}
		{%- if prop.is_array %}ListType[{{ type_klass_ }}]{% else %}{{ type_klass_ }}{% endif -%}
	{% endset %}
	{%- set title %}
		{% if prop.is_array %}List of{% else %}Type{% endif %} `{{ prop.class_name }}`{% if prop.is_array %} items{% endif %}
		{%- if prop.reference_to_names|length > 0 %} referencing `{{ prop.reference_to_names|join(', ') }}`{% endif %}
		{%- if prop.json_class != prop.class_name %} (represented as `{{ prop.json_class }}` in JSON){% endif %}
	{% endset %}
    {{ prop.name }}: {{ type_klass }} = Field(
		{% if prop.nonoptional and not prop.one_of_many %}...{% else %}None{% endif %},
		alias="{{ prop.orig_name }}",
		title={{ custom_mac.pep8_string_wrap(title|trim|replace("\n", ""), width=70).rstrip()}},
		description={{ custom_mac.pep8_string_wrap(prop.short, width=70).rstrip()}}{%- if prop.one_of_many%},{% endif %}
        {%- if prop.one_of_many%}
		one_of_many="{{ prop.one_of_many }}", # Choice of Data Types. i.e value[x]
		one_of_many_required={% if prop.nonoptional %}True{% else %}False{% endif %}
        {%- endif %}
	)

{%- endfor %}
{% if klass.name in one_of_many_fields %}
    @root_validator(pre=True)
    def validate_one_of_many(
        cls, values: Dict[str, Any]
    ) -> Dict[str, Any]:
        """https://www.hl7.org/fhir/formats.html#choice
        A few elements have a choice of more than one data type for their content.
        All such elements have a name that takes the form nnn[x].
        The "nnn" part of the name is constant, and the "[x]" is replaced with
        the title-cased name of the type that is actually used.
        The table view shows each of these names explicitly.

        Elements that have a choice of data type cannot repeat - they must have a
        maximum cardinality of 1. When constructing an instance of an element with a
        choice of types, the authoring system must create a single element with a
        data type chosen from among the list of permitted data types.
        """
        one_of_many_fields = {
	        {%- for prefix in one_of_many_fields[klass.name] %}
			"{{ prefix }}": [
				{%- for field in one_of_many_fields[klass.name][prefix] %}
			    "{{ field }}",
				{% endfor -%}
		    ],
	        {% endfor -%}
	    }
        for prefix, fields in one_of_many_fields.items():
            assert cls.__fields__[fields[0]].field_info.extra["one_of_many"] == prefix
            required = (
                cls.__fields__[fields[0]].field_info.extra["one_of_many_required"]
                is True
            )
            found = False
            for field in fields:
                if field in values and values[field] is not None:
                    if found is True:
                        raise ValueError(
                            "Any of one field value is expected from "
                            f"this list {fields}, but got multiple!"
                        )
                    else:
                        found = True
            if required is True and found is False:
                raise ValueError(f"Expect any of field value from this list {fields}.")

        return values
{% endif -%}
{%- endfor %}

